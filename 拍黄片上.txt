手机端特有的Meta标签<meta name="viewport" id="viewport" content="width=device-width,initial-scale=1">
===================*************===========================================
http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容
<meta http-equiv="content-type" content="text/html;charset=utf-8">


帧标签 border="0"  把边框取消
=================================================
css
优先级  关联(组合)选择器>>ID选择器>>类（class）选择器（.one{color}）>>html选择器（div{color：red}）

相对定位 相对于自己的位置   relative
绝对定位  相对于左上角0点位置	absolute

<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
IE 最小高度为18px 

jquery滑动slideDown（）也是一种隐藏。
=====================PHP===============================
static关键字  保持一个变量值不变。使之可以++
EG：<?php
function myTest() {
   static $x=0;
   echo $x;
   $x++;
}

myTest();
echo "<br>";
myTest();
echo "<br>";
myTest();
echo "<br>";
myTest();
echo "<br>";
myTest();
?>  

输出：
0
1
2
3
4

用isset（$a）判断一个变量存不存在且不为null   unset($a)来释放变量 
php变量和常量区分大小写，其他不区分。
运算符号（PHP）操作符号 
    一、算术运算符    +   -  *  /  %  ++  --
    二、字符串运算符  .  可以叫连接运算符号 
   三、赋值运算符    =   += -= *= /= %=  .= 
    四、比较运算符    >  <  >= <= == ===  != 或<> !== 
    五、逻辑运算符    && 或and  ||或 or  ! 或not   
     六、位运算符      &   ｜ ^ ~   <<  >> >>>
   七、其他运算符   ? :  ``  @  => -> ::  & $
     
逻辑运算符只能操作bool型值， 返回的也是bool型值
% 有两个目的： 整除运算； 控制范围, 不要用小数，也不要用负数 %会把两边的数转为整数后再进行整除。
  $a++;       //$a=$a+1;     先用变量再自增1
   ++$a;      //$a=$a+1;     先用自增1再用变量
  $a--;       //$a=$a-1;     先用变量再自减1
 --$a;        //$a=$a-1;     先用自减1再用变量
=====================================================================================
变量名可以动态设置和使用
变量的引用赋值 使用&符号加到原变量前面----把位置传过去
带有&参数的函数， 表示引用赋值， 这个参数不能传值，只能传一个变量，然后函数将变量的值改变，我们在使用这个变量时，值也是变化的
bool arsort ( array &array [, int sort_flags] )
=======================================================================================
	$int=10;   //十进制声明
	$int=045;  //以0开头的表示以8进制声明一个变量
	$int=0xff; //以0x或0X开头的表示以16进制声明一个变量 0-9 a-f 0X A-F
	$int=-5;   
	//整数的最大值 4字节   2的32次方， 214483647

	$float=10;
	$float=-10;
	$float=3.14E5;
	$float=3.15E+5;  //3.15*10的5次方
	$float=5.14E-2;  //E可以大写也可以小写

	//以下都是false的情况
	$bool=false;   //true
	$bool=0;       //非0的数
	$bool=0.000;   //有非0的数出现
	$bool="";      
	$bool=" ";     
	$bool=null;    //非空代表
	$bool="0";    //非空非0的字符串
	$bool=array();	  //有成员的数组

*****内容详见第三部分22节********
	//字符串的声明有多种方法
	//1. 单引号和双引号都可以声明字符串
	//2. 声明的字符串没有长度限制
	//3. 在双引号的字符串中，即可以直接解析变量，又可以直接使用转义字符（解析所有的转义符）
	//4. 在单引号的字符串中，不可以解析变量，也不可以使用转义字符(可以以转义单引号本身，也可以转义转义字符"\")   \' 或  \\
	//5. 在双引号中不能再使用双引号，在单引号中不能使用单引号
	//最好使用''单引号
	//定界符号声明字符串，大量字符串。hello可以自定义，他后面不能有任何字符，空格也不可以，也要以这个字符串结束，但结束前也不能有任何字符。
===================*******这是heredoc的结构语法！！！******====================
	$str=<<<hello
	jlkaj;ffffffffffffffffjasdfm,.nz.,cxvno;as   <------字符串

hello;

例子：
$table=<<<wao
<table border="1">
<tr>
<td>编号</td>
<td>姓名</td>
<td>描述</td>
</tr>
<tr>
<td>1</td>
<td>king</td>
<td>siad</td>
</tr>
<tr>
<td>2</td>
<td>height</td>
<td>hear</td>
</tr>
</table>
wao;
//heredoc two
echo $table.'<hr><br>';
echo <<<jing
<h1>真的惊艳了！</h1>

jing;
echo "<br><hr>";
//heredoc three
echo <<<"me"
<h2>明白了！！</h2>
me;

================================nowdoc的语法==============================
nowdoc语法结构，相当于单引号的作用


==========================================================================
php文件的命名不能是中文。
与变量和类型有关的一些常用函数
     isset(); 值如果是null，也表示空
     empty();  //判断一个变量是否为空， “”  null
     unset(); //释放变量
 
     setType();  
 
     getType();  //var_dump();
 
     变量类型测试函数
     is_bool();
     is_int() is_integer() is_long()
     is_string();
     is_float(), is_double() is_real()
     is_array()
     is_object()
     is_resource()
     is_null();
 
     is_scalar()
     is_numberic()
     is_callable()
 
  常量的声明与使用
       1. 常量是一个简单值的标识符
       2. 常量定义后不能再改变他的值，也不能使用unset()取消
       3.常量可以不用理会变量范围的规则而在任何地方都可以定义和访问
       4.常量使用define("常量名"， 值);
       5.常量声明名在声明和使用都不使用"$"
       6.常量名称习惯都使用大写
       7.常量的值只能用标量类型（int, float, bool, string）
       8.常量一定要在声明时就给值
       9.defined("常量");
=============================PHP函数的声明，调用============
 函数的定义：
    1. 函数是一个被命名的
    2.独立的代码段
    3.它执行特定任务
    4.并可以给调用它的程序返回一个值
 
 
    函数的优点：
    	1. 提高程序的重用性
    	2. 提高程序的可维护性
    	3.可以提高软件的开发效率
    	4.提高软件的可靠性
    	5.控制程序的复杂性
 
 
    函数的声明
 
    function 函数名(){
 	函数体
    }
 
    function 函数名(参数1, 参数2, 参数.... )  //参数列表，如果有多个就用,分开
    {
 		函数体
    }
 
    function 函数名(){
 	
 		函数体
 		返回值；
    }
    function 函数体(参数列表){
 		函数体
 		返回值
    }
    一、函数必须调用才能执行，可以在声明之前调用，也可以在函数声明之后调用
    二、函数名命名和变量一样， aaa bbb ccc  aaaBbbCcc, 函数名称一定要有意义
    三、函数在声明时不能重名
   
    四、可以通过向函数传递参数，改变函数的行为
        形参：就在声明函数时，声明的参数，参数就是变量，多个参数用，分开
        实参: 调用 函数时传给形参数值（数据，也可以变量）
    五、如果没有返回值则称为过程
    六、通过使用return 语句返回数据

数据类型之间相互转换
  	一种是强制转换：
  		setType(变量， 类型);  //类型int, integer, float, double,real, bool, boolena, string, array, object
 		这个函数将原变量的类型改变，var_dump();//打印变量相关信息
 
 		在赋值前使用(类型)的形式, 不会改变原变量的类型
 
 		$a=(int)"123abc";
 		
 		$变量=intval(变量或值);
 		$变量=floatval(变量或值);
 		$变量=stringval(变量或值);
 
 		注意： 整型在内存中占4个字节，  2.147e9
 			浮点型在内存中点8个字节
 
  		字符串
  	一种自动转换 ： 最常用的方式，因为这种我们开发时不用去管理类型，变量会根据运行环境自动转换 
变量函数：如果一个变量后面有括号$var=hello   $var(),就将寻找与变量同名的函数hello();
函数的返回值：调用后怎么处理这个函数
一定要先使用系统函数，如果系统函数没有想要的功能，再去自己定义函数
回调函数 带有callback,  就是调用这个函数时需要我们传一个函数进来（函数名，函数名字串）
     	 array array_filter ( array input [, callback callback] )

$b = array(1,3,5,7,-7,-9,-2);
print_r(array_filter($b,"demo"));

function demo($n){
	if ($n>0) {
		return true;
	}else
	return false;
}

//两种调用变量的方式
echo "你的php成绩是".$php.'分'.php($php).'<br>';
echo "你的php成绩是{$php}分".php($php)."<br>";

一、数组的概述(**数组里面的元素用（单双）引号包裹***)
  	1. 数组的本质：管理和操作一组变量，成批处理
  	2. 数组是复合类型
  	3. 数组中可以存储任意长度的数据，也可以存储任意类型的数据
       4. 数组就可以完成其它语言数据结构的功能（链表， 队列， 栈， 集合类）
       
  二、数组的分类
      数组中存有多个单元，（单元称为元素）
      每个元素（下标［键］和值）
      单访问元素时候，都是通过下标（键）来访问元素
 
  	1. 一维数组， 二维数组， 三维数组 。。。 多维数组
 	（数组的数组， 就是在数组中存有其它的数组）
 	2. PHP中有两种数组
 	索引数组：就是下标是顺序整数作为索引  
 	关联数组：就是下标是字符串作为索引
 
 	下标（整数， 字符串）只有这两种
 
  三、数组多种声明方式
 
      1. 直接为数组元素赋值
      	   a.如果索引下标不给出，就会从0开始顺序索引
 	   b.如果给出索引下标，下一个就会是从最大的开始增1
 	   c.如果后面出现前面的下标，如果是赋值就是为前面的元素重新赋值
           
          d. 混合声明时，索引和关联不互相影响(不影响索引下标的声明)
      2. 使用array()函数
      	  a. 默认是索引数组
      	  b.如果为关联数组和索引数组指定下标，使用 键=>值
      3. 使用其它的函数声明
         file();

数组的遍历
1. 使用for语句循环遍历数组
  	  a. 其它语言（只有这一种方式）
          b. PHP中这种方式不是我们首选方式
          c. 数组必须是索引数组，而且下标还必须是连续的
             （索引数组下标还可以不连序，数组还有关联数组）
    
 
  	2. 使用foreach语句循环遍历数组
  	   
foreach(数组变量 as 变量值){
 		//循环体
  	   }
  	   a. 循环次数由数组的元素个数决定
  	   b. 每一次循环都会将数组中的元素分别赋值给后面变量
 	   
	   //foreach($user as $key=>$val)  中$key和$val可以自定义变量
  	   foreach(数组变量 as 下标变量=> 值变量){
 		
  	   }
 
  	3. while() list() each() 组合循环遍历数组
 
        each()函数， 
        	a. 需要一个数组作为参数
        	b. 返回来的也是一个数组
        	c. 返回来的数组是0, 1, key, value四个下标(固定的)
        	 0和key下标是当前参数数组元素的I
        	 1和value下标是当前对数数组元素的值
 
               d. 默认认当前元素就是第一个元素
               e. 每执行一次后就会将当前元素向后移动
               f. 如果到最后的元素再执行这个函数，则返回false
 
 		//Array ( [1] => 1 [value] => 1 [0] => id [key] => id ) 
     
       list()函数
 
  		a. list()=array(); 需要将一个数组赋值给这个函数
  		b. 数组中的元素个数，要和list()函数中的参数个数相同
  		c. 数组中的每个元素值会赋值list()函数中的每个参数，list()将每个参数转为变量
  		d. list()只能接收索引数组
  		e. 按索引的下标的顺序\
=========================预定义数组==========================================
  	自动全局变量---超全局数组
 
  	1. 包含了来自WEB服务器，客户端，运行环境和用户输入的数据
  	2. 这些数组比较特别
  	3. 全局范围内自动生效，都可以直接使用这些数组
  	4. 用户不能自定义这些数组, 但这些数据操作方式又和我们自定义的数组操作方式一样
  	5. 在函数中直接可以使用这些数组
 
$GLOBALS    //只要是当前脚本有效的变量都在这里，数组键名为全局变量的名称
$_COOKIE	得到会话控制中cookie传值
$_SESSION	得到会话控制中session的值
$_FILES	得到文件上传的结果
$_GET	得到get传值的结果
$_POST	得到post传值的结果
$_REQUEST	即能得到get的传值结果，也能得到Post传值的结果


==============================数组处理函数=========================
一 数组键/值操作有关的函数
   	1.  array_values()
   	2.  array_keys()
   	3.  in_array()
 	4. array_key_exists
	5.array_flip -- 交换数组中的键和值
	6. array_reverse --  返回一个单元顺序相反的数组 
   
    二、 统计数组元素的个数和惟一性

    1. count() sizeof();
    2. array_count_values -- 统计数组中所有的值出现的次数
    3. array_unique -- 移除数组中重复的值

    三、使用回调函数处理数组的函数
    	1. array_filter()  用回调函数过滤数组中的单元 
	2. array_walk()   数组中的每个成员应用用户函数
	3. array_map()     将回调函数作用到给定数组的单元上
=======================数组的排序函数===============================
数组的排序函数
     sort()
     rsort()
     usort()
     asort()
     arsort()
     uasort()
     ksort()
     krsort()
     uksort()
     natsort()
     natcasesort()
     array_multisort()
 
     1. 简单的数组排序
       sort() rsort()
     2. 根据键名对数组排序
     	ksort() krsort()
     3. 根据元素的值对数组排序
       asort() arsort()
     4. 根据“自然数排序”法对数组排序
     	natsort()  natcasesort()
     5. 根据用户自定义规则对数组排序
        usort() uasort() uksort()
      6.多维数组的排序
       array_multisort
  
  拆分、合并、分解、接合的数组函数
     1. array_slice()
     2.array_splice()
     3. array_combine();
     4. array_merge();
     5. array_intersect();
     6. array_diff()
 
 
 
  数组与数据结构的函数
     1. 使用数据实现堆栈
     	 array_push()
     	 array_pop()
 
     2. 使用队列
     	  array_unshift()
     	  array_shift()
 
     	  unset()
        
 
  其它与数据操作有关的函数 
 
       array_rand();
       shuffle()
       array_sum()
       range()

==============================================
类和对象之间一个关系
 
    声明类-->实例化对象（创建对象）--->用对象
=====================================================
在类中声明成员属性时： 前面必须有修饰词,当不知道使用那个时，就使用var,如果知道使用那一个修饰关键字，就不使用var了.
通过类来实例化对象
   	1. 使用的是new 新建一个对象，加上类名，就是创建那个类的对象
   		$对象引用=new 类名;
   	2. 只要有一个new 关键字就是创建一个对象，创建一个对象就在内存中分配了一个空间
   只有对象才在内存有存储空间
=============================================
1. 对象中成员的访问（就是在一个对象的内部方法中，去访问本对象中的其它方法和成员属性）
  2. 在对象中的方法中都默认有一个$this关键字， 这个关键字代表调用这个方法的对象
  相当于第一人称代词：我
   
   构造方法， 构造器
 
     1. 是对象创建完成以后，“第一个” “自动调用”的方法
     2. 构造方法的定义， 方法名一个固定的，
     	 在PHP4中 和类名相同的方法就是构造方法
     	 在PHP5中 构造方法选择使用 魔术方法 __construct() 所有类中声明构造方法都使用这个名称
         	 	优点： 在改变类名时，构造方法不用改变 
       作用：就是为成员属性初使化；
     	
 
     	魔术方法：
     		在类中写出了某个魔术方法， 这个方法对象的功能 就会添加上
 
     		方法名称都固定的（都是系统给我们提供好），没有自己定义的， 
 
     		每一个魔术方法， 都是在不同时刻为了完成某一功能自动调用的方法
     		不同的魔术方法有不同调用 时机
 
     		都是以 __开头的方法
 
     		__construct();
     		__destruct();
 
     		__set();
     		__get();
     		__isset();
     		__unset();
 
     		__clone();
 
     		__call();
 
     		__sleep();
 
     		__weakup();
 
     		__toString()
 
     		... 
 
               __autoload();
   
 
   析构方法：
 
   	1. 当对象被释放之前最后一个 “自动”调用的方法
 
  	使用垃圾回收器（java PHP）而C++手动的释放
 
  	作用：关闭一些资源， 作一些清理的工作
 
       __destruct();
 
=============================================

private 只能在自己类中使用，protected在自己类和子类中使用，public都能用

子类重载父类的方法

子类可以声明和父类相同的方法名，即子类覆盖了父类中的同名方法
子类对父类的扩展，调用父类中被覆盖的方法。对象->成员   
类:: 成员   父类名::方法名（）  parent::方法名（）

在子类编写构造方法，如果父类中也有构造方法一定要去调用一次父类中被覆盖的那个构造方法
子类中重载的方法，不能低于父类中的访问权限（子类可以放大权限，不能缩小权限）
================================================================
PHP中常用的关键字

  	final （最终的版本）
  		1. final不成修饰成员属性（类中常量不是用这个关键字）
  		2. final只能修饰类和方法
 
  		作用：
  			使用final修饰的类 不 能被子类继承
  			使用final修饰的方法不能被子类去覆盖
 
  			用来限制类不被继承，方法不被覆盖就使用fianl
 
  	static
  		1. 使用static可以修饰成员属性和成员方法，不能修饰类
 
  		2. 用static修饰的成员属性，可以被同一个类的所有对象共享
 		
 		3. 静态的数据是存在 内存中的 数据段中（初使化静态段）
 
 		4. 静态的数据是在类每一次加载时 分配到内存中的， 以后再用到类时就直接从数据段中获取
 
 		5. 什么是类被加载？ 只要在程序中使用到这个类（有这个类名出现）
 
		注意： 静态成员属性和静态方法都要使用类名去访问，不用创建对象, 不要用对象去访问
 			
 		类外，类中都可以使用  类名::静态成员/静态方法  的方式来访问
 		如果在类中使用静态成员和静态方法,可以使用 self::静态成员/静态方法	self代表本类（$this代表本对象）
 
 		6. 静态方法（static修饰的方法）， 不能访问非静态的成员（在非静态的方法中，可以访问静态成员）
 
 		因为非静态的成员,就必须用对象来访问，访问内部的成员使用的就是$this
 
 		静态方法 不用使用对象来调用， 也就没有对象， $this也就不能代表什么对象， 非静态的成员还必须使用对象
 
 		如果你确定一个方法不使用非静态的成员， 则可以将这个方法声明为 静态方法（不能创建对象，直接使用类名就可以访问）		

  	const 《--类常量   与静态关键字使用一样
  		1. 他只能修饰成员属性
 
 		常量申明 define('HOST', 'www.xsphp.com');

 		2. 类中声明常量属性使用const
 
 		3. 命名的方式和我们以前学习 define是一样的效果
 
 		4. 访问方式和static静态成员属性是一样（在类外部使用  类名::常量， 在类内部使用  self::常量）
 
 		5. 常量一定要在声明时就给初值
 
 	$this   self   parent  .... 
 

  PHP中常用的魔术方法
  	
 	__call() 
 		
 		作用: 在调用对象中不存在的方法时就会出现系统报错，然后程序退出。
 
 		什么时候自动调用: 就会在调用一个对象中不存的的方法时自动调用
 
 		处理一些不存在方法的错误调用
 
 		这个方法需要两个参数
 
 	__toString()
 		直接输出对象引用时自动调用， 用来快速获取对象的字符串表示的最便捷的方式
 	
 
 	__clone()
 		克隆对象使用clone去处理
 
 		原本 （原来的对象）
 
 		复本 （复制出来的对象）
 
 
  		__clone()就是在克隆对象时自动调用的方法
 
 
  		只要一个对象一诞生，就要有初使化的动作， 和构造方法__construct作用相似
 
  		在__clone()方法中的 $this关键字，代表的是复本, $that代表原本对象
 
 		
 	__autoload()
 		注意： 其它的魔术方法都是在类中添加起作用， 这是一个唯一一个不在类中添加的方法
 
 		只要在页面中使用到一个类，只要用到类名就会自动将类名传给这个参数
 
             
      对象串行化（序列化）： 将一个对象转为二进制串 （对象是存储在内存）
 
      		   1. 将对象长时间存储在数据库或文件中时
      		   2. 将对象在多个PHP文件中传输时
 
 		serialize() : 参数是一个对象， 返回来的就是串行化后的二进制串	
 		unserialize() : 参数就是对象的二进制串， 返回来的就是新生成的对象
 
  	__sleep()
 
  		是在序列化时自动调用的方法
 
		作用：就是可以将一个对象部分串行化

			只要这个方法中返回一个数组，数组中有几个成员属性就序列化几个成员属性，如果不加这个方法，则所有成员都被序列化
 	__wakeup()
 	
 		是在反序列化时自动调用的方法
 
 		也是对象重新诞生的一个过程(__construct(), __clone(),__wakeup())
==========================================================================================
this：指向当前对象的指针，实例化具体某一个对象
self：指向当前类的指针，多用静态变量的访问
parent：指向父类的指针

抽象类是一种特殊的类， 接口是一种特殊的抽象类， 而多态就要使用到抽象类或是接口
 
   声明抽象类和接口，以及一些需要的技术
 
   抽象类
 
       什么是抽象方法？
 
       	定义：如果一个类中的方法，没有方法体的方法就是抽象方法(就是一个方法没有使用{}而直接使用分号结束)
       		
       		abstract function test();  //抽象方法
 			
 			function test(){  //有方法体，但方法体为空的
 				
 			}
 
 			如果一个方法是抽象方法，就必须使用abstract修饰
 
 		
 
 		为什么要使用抽象方法？   作用：就是定义一些规范，让子类按这些规范去实现自己的功能。要将自己写的程序模块加入到原来已经写好的程序中区（别人写好的程序，不能等你开发完再继续开发）
       	
 
   	什么是抽象类？
   		
   		1. 如果一个类中，有一个方法是抽象的则这个类就是抽象类
   		2. 如果一个类是抽象类，则这个类必须要使用abstract修饰
   		3. 抽象类是一种特殊的类，就是因为一个类中有抽象方法，其他不变。也可以在抽象类中声明成员属性，常量，非抽象的方法。
   		4. 抽象类不能实例化对象（不能通过抽象类去创建一个抽象类的对象）
 
 
   		一、抽象方法没有方法体，不知道做什么的（没写功能）
   		二、对象中的方法和属性都要通过对象来访问，除常量和静态的变量和方法，  而抽象类又不能创建对象，抽象类中的成员都不能直接访问

	作用：
   	要想使用抽象类，就必须使用一个类去继承抽象类，而且要想使用这个子类，也就是让子类可以创建对象，子类就必须不能再是抽象类，子类可以重写父类的方法（给抽象方法加上方法体）
 
 		抽象方法中的方法没有方法体， 子类必须实现这个方法 （父类中没写具体的实现， 但子类必须有这个方法名）
 
 
 	抽象类和接口的作用：就是在定义一些规范，让子类按这些规范去实现自己的功能。因为子类继承抽象类和接口都要实现所有的抽象方法。
 
 	目的： 就是要将你自己写的程序模块 加入 到原来已经写好的程序中去 （别人写好的程序，不能等你开发完一个小模块，根据你的小模块继续向后开如）
多态：  多态是面向对象的三大特性之一
 
“多态”是面向对象设计的重要特性，它展现了动态绑
定（dynamic binding）的功能，也称为“同名异
式”（Polymorphism）。多态的功能可让软件在开发和维护
时，达到充分的延伸性（extension）。事实上，多态最直接
的定义就是让具有继承关系的不同类对象，可以对相同名称
的成员函数调用，产生不同的反应效果。

========================================================================
接口技术
 
  接口是一种特殊的抽象类， 抽象类又是一种特殊的类
 
 
  接口和抽象类是一样的作用
 
  因为在PHP是单继承的， 如果使用抽象类，子类实现完抽象类就不能再去继承其它的类了。
 
  如果即想实现一些规范， 又想继承一个其他类。就要使用接口
 
     接口和抽象类的对比
 
     1. 作用相同，都不能创建对象， 都需要子类去实现
     2. 接口的声明和抽象类不一样
     3. 接口被实现的方式不一样
 
     4. 接口中的所有方法必须是抽象方法，只能声明抽象方法（不用使用abstract修饰）
     5. 接口中的成员属性，只能声明常量，不能声明变量
 
     6. 接口中的成员访问权限 都必须是public, 抽象类中最低的权限protected
   
     7. 使用一个类去实现接口， 不是使用extends关键字， 而是使用implements这个词
 
 	 如果子类是重写父接口中抽象方法，则使用implements, 类--接口， 抽象类---接口 implements 接口---接口 extends
 
     可以使用抽象类去实现接口中的部分方法
     如果想让子类可以创建对象，则必须实现接口中的全部抽象方法
     
     可以定义一个接品口去继承另一个接品口
 
     一个类可以去实现多个接口（按多个规范去开发子类）, 使用逗号分隔多个接口名称
 
     一个类可以在继承一类的同时，去实现一个或多个接口(先继承，再实现)
 
     使用implements的两个目的
     	1. 可以实现多个接口 ，而extends词只能继承一个父类
     	2. 没有使用extends词，可以去继承一个类， 所以两个可以同时使用
 
 
 
 
    
 
     class 类名{
 
     }
	抽象类
     abstract class 类名 {
 
     }
 
    声明方式
 
    interface 接口名{
 
    }
=====================================================================================
继承性： 
  	1. 他也是面向对象的三大特性之一
  	2. 开放性、可扩充性
  	3. 增加代码的重用性
  	4. 提高了软件的可维护性
 
       5. 继承就是用子类去”扩展“父类
 
       6. 鸟--- 砖头
 
       C++ 属于多继承, 同一个类可以有多个父类
 
       PHP和Java属于单继承， 同一个类只能有一个父类
 
       不管多继承的还是单继承的都可以有多个子类
 
       只要你在设计两个类时，有可以共享的成员，就将可以共享的内容拿出来，单独作为一个基类使用
 (属性多的继承属性少的)
       父类--基类
       子类--派生类
 
       
 
  	作用：
 
 
  一、类继承的应用
 
 	 1. 	声明一个子类，使用 extends 关键字 去继承（扩展）一个父类
 
  	2.  子类可以从父类，继承所有的内容，包括成员属性，成员方法， 构造方法 ..., 在子类中都可以直接使用
 
  	3. 父之间的层次关系设计好
 
  二、访问类型控制
  	虽然子类可以从父类中继承所有内容，但private的成员， 只能在本类中使用， 子类中也不能使用
 
  	封装时，即可以让自己类的内部可以访问，也让子类可以用，但类的外部不能使用， private --> protected
 
  三、子类中覆盖父类的方法（php 是没有重载的，是弱类型语言）
 
    1. 子类可以声明和父类相同的方法名，即子类覆盖了父类中同名的方法
 
    鸟类---鸵鸟（飞方法）， 在鸵鸟类中将 “飞的方法改写”
 
    子类的方法对父方法的扩展
 
    在子类中 调用 父类中 被覆盖的方法 
 	
 	对象->成员  类::成员
 
    	父类名::方法名()
    	parent::方法名()
 
 
    在子类中编写构造方法，如果父中也有构造方法一定要去调用一次父类中被覆盖的那个构造方法
 
    注意： 子类中覆盖父类的方法，不能低于父类中访问权限， （子类可以访大权限，但不能缩小权限）


==============================================================================
预定义字符是：
单引号（'）
双引号（"）
反斜杠（\）
NULL
===============================正则表达式======================================
一、正则表达式的模式如何编写
	语法：
		1. 定界符号  // 
			除了字母、数字和正斜线\ 以外的任何字符都可以为定界符号
			| |
			/ /
			{ }
			! !
			
			没有特殊需要，我们都使用正斜线作为正则表达式的定界符号


		2. 原子   img \s . 
			注意：原子是正则表达式的最基本组成单位，而且必须至少要包含一个原子
			只要一个正则表达式可以单独使用的字符，就是原子

			1. 所有打印（所有可以在屏幕上输出的字符串）和非打印字符（看不到的）
			2. \. \* \+ \? \( \<\> 如果所有有意义的字符，想作为原子使用，统统使用 ”\“转义字符转义 m
				" \ "转义字符可以将有意的字符转成没意义的字符，还可以将没意义的字符转为有意义的字符
			3. 在正则表达式中可以直接使用一些代表范围的原子
				\d  : 表示任意一个十进制的数字       [0-9]
				\D  : 表示任意一个除数字这外的字符   [^0-9]
				\s  : 表示任意一个空白字符，空格、\n\r\t\f   [\n\r\t\f]
				\S  : 表示任意一个非空白                     [^\n\r\t\f ]
				\w  : 表示任意一个字 a-zA-Z0-9_              [a-zA-Z_0-9]

				\W  : 表示任意一个非字（就是特殊字符）， 除了a-zA-Z0-9_以外的任意一个字符  [^a-zA-Z0-9_]
			4. 自己定义一个原子表[], 可以匹配方括号中的任何一个原子
				[a-z5-8]
				[^a-z] 表示取反，就是除了原子表中的原子，都可以表示(^必须在［］内的第一个字符处出现)

			.	


		3. 元字符  * ? 
			元字符是一种特殊的字符，是用来修饰原子用的，不可以单独出现
			*  : 表示其前的原子可以出现 0次、1次、或多次                       {0,}
			+  : 表示其前的原子可以出现1次 或多次， 不能没有最少要有一个       {1,}
			?  ： 表示其前面的原子可以出现0次或1次， 有只能有一次，要么没有    {0,1}
			{} : 用于自己定义前面原子出现的次数
				{m}   //m表示一个整数， {5}表示前面的原子出现5次
				{m,n}  //m和n表示一个整数，{2,5} m要小于n, 表示前面出现的原子，最少m次，最多n次，包括m和n次
				{m,}   //表示前面的原子最少出现m次,最多无限	
				
			.   : 默认情况下，表示除换行符外任意一个字符

			^   : 直接在一个正则表达式的第一个字符出现，则表达必须以这个正则表达式开始
					eg: /^one$/  就是匹配one 这个字符串的
			$   : 直接在一个正则表达式的最后一个字符出现，则表达必须以这个正则表达式结束

			|   : 表示或的关系 , 它的优先级号是最低的， 最后考虑它的功能.如果是像这样的/a(t|d)o/正则匹配则匹配ato,ado。atdo将不能匹配

			\b  : 表示一个边界
			\B  ： 表示一个非边界

			()  : 重点

			一、 () 作用： 是作为大原子使用
			二、 改变优先级,加上括号可以提高优先级别
			三、 作为子模式使用, 正则表达式不先对一个字符串匹配一次, 全部匹配作为一个大模式，放到数组的第一个元素中，每个()是一个子模式按顺序放到数组的其它元素中去。
			四、可以取消子模式，就将（）作为大原子或改变优先级使用, 在括号中最前面使用"?:"就可以取消这个（）表示的子模式
			五、反向引用， 可以在模式中直接将子模 式取出来，再作为正则表达式模式的一部分， 如果是在正则表达式像替换函数preg_replace函数中， 可以将子模式取出， 在被替换的字符串中使用

			\1 取第一个子模式、 \2取第二个子模式， ....  \5 (注意是单引号还是双引号引起来的正则)

			"\\1"
			'\1'
			
			${1} ${2}

			\* \+ \. \?

		4. 模式修正符号	 i 
		U 正则表达式的特点：就是比较贪婪，  .* .+所有字符都符合这个
		一种使用模式修正符号 U
		另一种是使用？完成 .*?  .*?
		如果这两种方法同时出现又开启了贪婪模式 



		
		"/\<img\s*src=\".*?\"\/\>/iU"
		"#\<img\s*src=\".*?\"\/\>#iU"

		/原子和元字符/模式修正符号   / 为定界符号 （有一些语言是不需要这个定界符号）

	二、学习正则表达式的强大处理函数
		preg_match();
=======================================================
fopen的模式：
模式	说明
r	只读方式打开，将文件指针指向文件头。
r+	读写方式打开，将文件指针指向文件头。
w	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建
w+	读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建
a	写入方式打开，将文件指针指向文件末尾(在末尾加字符)。如果文件不存在则尝试创建
a+	读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之
x	创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建
x+	
创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建

编辑器选择字体最好选择等宽字体便于区分i1l字体 常见等宽字体为Courier New，Consolas,Source Code Pro(推荐)

md5(uniqid(mt_rand(),true)) 生成唯一随机数